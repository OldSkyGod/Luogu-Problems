# [COCI2018-2019#6] Lun

## 题目描述

现有一个判断某种银行卡号是否合法的算法：

1. 从倒数第二位开始从右往左，每隔一个数位就将其乘 $2$，否则保留原数位不变。
2. 将被乘 $2$ 的数位分别计算其数位之和。
3. 计算经过操作之后的所有数位之和，并将其乘 $9$ 再对 $10$ 取模，检验其是否等于最后一位（即银行卡号的校验码）。

若待验证卡号为 $79927398713$，则判断方法如下：

|银行卡号各数位|$7$|$9$|$9$|$2$|$7$|$3$|$9$|$8$|$7$|$1$|$3$|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|每隔一位乘 $2$（从倒数第二位开始向左）|$7$|$\red {18}$|$9$|$\red 4$|$7$|$\red 6$|$9$|$\red {16}$|$7$|$\red 2$| -|
|计算得到的数位和并累加|$7$|$\green 9$|$9$|$4$|$7$|$6$|$9$|$\green 7$|$7$|$2$|$=67$|

将得到的和 $67$ 乘 $9$ 再对 $10$ 取模，得到 $67 \times 9 \bmod 10=3$。其中 $3$ 为该银行卡号校验码，因此原卡号合法。

现有一个缺失一个数位的银行卡号，请根据上述算法在缺失数位处补充一个合适的数位，使得得到的银行卡号合法。

## 输入格式

第一行输入整数 $N$，表示缺失数位的银行卡号的长度。

第二行有一个长度为 $N$ 的字符串，表示银行卡号。该字符串中只包含数位 $0 \sim 9$ 和字符 `x`。字符 `x` 将且仅将出现一次，表示缺失的数位。

## 输出格式

输出符合题意的数位。如果有多种符合题意的数位，则输出最小的。

## 样例 #1

### 样例输入 #1
```
11
7992739871x
```

### 样例输出 #1

```
3
```

## 样例 #2

### 样例输入 #2
```
5
x2464
```

### 样例输出 #2

```
5
```

## 样例 #3

### 样例输入 #3
```
10
93380x1696
```

### 样例输出 #3

```
1
```

## 提示

#### 数据规模与约定

对于 $50\%$ 的数据，缺失的数位位于银行卡号校验码处，即字符 `x` 位于字符串最后一位。

对于 $100\%$ 的数据，$1 \le N \le 100$。

#### 说明

**本题分值按 COCI 原题设置，满分 $50$。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #6](https://hsin.hr/coci/archive/2018_2019/contest6_tasks.pdf)  _T1 Lun_。**
