# 滴水不漏

## 题目描述

Gnar 购买了 $n$ 个水缸，其中第 $i$ 个水缸的容积为 $i$ 且因不明原因初始装有 $a_i$（$0 \le a_i \le i$）单位的水。

好奇的 Gnar 想知道每个水缸装有的水量，但肉眼观察显然不可行，他希望你能帮他计算解决这个难题。

Gnar 唯一能替你执行的操作是，由你先指定 $i, j$（$1 \le i, j \le n$），然后：

- 若 $i \neq j$，滴水不漏地将第 $i$ 个水缸的水往第 $j$ 个水缸倒，直到第 $i$ 个水缸的水被倒完或第 $j$ 个水缸已满。Gnar 会告诉你操作后第 $j$ 个水缸是否是满的。注意倒水的影响会**保留**而不是恢复到操作前。
- 若 $i = j$，Gnar 做不到让一个水缸的水往自己倒，他会直接告诉你当前第 $j$ 个水缸是否是满的。

Gnar 只肯接受**最多** $20000$ 次操作，否则他会认为你在调戏他！

你的任务是利用不超过 $20000$ 次操作 Gnar 告诉的结果，完整求出最初的 $a_1,a_2,\ldots,a_n$。

当然 Gnar 不会动手脚，你所求的 $a_1,a_2,\ldots,a_n$ 在操作前已经存在，不随操作动态生成。

## 输入格式

输入单个正整数水缸个数 $n$ 以开始交互。

## 输出格式

在你确定答案后，用 `! a1 a2 ... an` 的形式输出一行以结束交互。

### 交互格式

交互过程中，用 `? i j` $(1 \le i,j \le n)$ 的形式输出一行以执行一次操作。然后你应输入一个布尔值，即操作的返回值 $x$。若 $x = 0$，表示第 $j$ 个水缸未满；若 $x = 1$，表示第 $j$ 个水缸已满。

上述的所有输入都应从**标准输入**中读入，所有输出都应向**标准输出**中输出。输出一行后必须**清空缓冲区**，否则你的评测将被判为 Time Limit Exceeded。清空缓冲区方式如下：

- 在 C++ 中，使用 `fflush(stdout)` 或 `cout.flush()`。
- 在 Pascal 中，使用 `flush(output)`。
- 在 Python 中，使用 `stdout.flush()`。
- 其他语言请自行查阅文档。

如果你的输出格式错误，或执行超过 $20000$ 次操作，你的评测将被判为 Wrong Answer。


## 样例 #1

### 样例输入 #1
```
2

0

1

0
```

### 样例输出 #1

```
? 1 1

? 2 1

? 1 2

! 0 1
```

## 提示

**【样例解释 #1】**

样例示意了一种可能的交互过程。

初始两个水缸中分别装有 $0,1$ 单位的水。

第一次操作，由于 $i = j$，你直接得知 $x = 0$ 即第一个水缸未满。

第二次操作后两个水缸装有水量分别为 $1,0$，而你得知 $x=1$ 即第一个水缸当前已满。

第三次操作后两个水缸装有水量分别为 $0,1$，而你得知 $x=0$ 即第二个水缸当前未满。

注意过程中确切水量并不传达给你，但是通过返回值 $x$ 你足够唯一确定 $a_1 = 0$，$a_2 = 1$。

----

**【数据规模与约定】**

**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。

- Subtask #1 (8 points)：$n = 2$。
- Subtask #2 (17 points)：$n \le 10$。
- Subtask #3 (15 points)：$n \le 100$。
- Subtask #4 (15 points)：$a_i \le 1$。
- Subtask #5 (25 points)：$n \le 500$。
- Subtask #6 (20 points)：无特殊限制。

对于所有的数据，保证 $2 \le n \le 1000$，$0 \le a_i \le i$。
