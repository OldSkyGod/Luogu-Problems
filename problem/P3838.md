# Toy Train 玩具火车

## 题目背景

# 滥用本题评测将被封号

### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。

## 题目描述

Arezou和她的兄弟Borzou是双胞胎。他们收到的生日礼物是一套好玩的玩具火车。他们用它建了一下$n$个车站和$m$段单向轨道的铁路系统。这些车站的编号是从$0$到$n-1$。每段轨道都始于某一车站，然后终于同一车站或其他车站。每个车站至少会有一段轨道以它为起点。

其中有些车站是充电车站。无论何时，如果火车抵达某个充电车站。无论何时，如果火车抵达某个充电车站，它都会被充到满电。满电火车拥有足够的动力连续地试过$n$段轨道，但是如果不再充电的话，在即将进入第$n+1$段轨道时它就会因电已用光而停车。

每个车站都有一个轨道开关，可以扳向任一以该车站为起点的轨道。火车从某个车站驶出时，驶向的正是该车站的开关所扳向的轨道。

这对双胞胎打算用他们的火车玩个游戏。他们已经分完了所有的车站：每个车站要么归Arezou，要么归Borzou。游戏里面只有一列火车。游戏开始时，这列火车停在车站$s$，并且充满了电。为启动游戏，车站$s$的拥有者把车站$s$的开关扳向某个以$s$为起点的轨道。随后他们启动火车，火车也就开始沿着轨道行驶。无论何时，在火车首次进入某一车站时，该车站的拥有者都要扳定车站开关。开关一旦扳定，它就会保持状态不变直到游戏结束。因此，火车如果开到了一个曾经进过的车站，就会沿着与之前相同的轨道开出该车站。

由于车站数量是有限的，火车的行驶最终都会落入某个环路。环路是指一系列**不同**的车站$c[0],c[1],\cdots ,c[k-1]$，其中火车在离开车站$c[i]\ \ (0\leqslant i < k-1)$后驶上连向车站$c[i+1]$的轨道，在离开车站$c[k-1]$后驶上连向车站$c[0]$的轨道。一个环路可能只包括一个车站（此时$k=1$），即火车从车站$c[0]$驶出后又驶上了连向车站$c[0]$的轨道。

如果火车能够连续行驶跑完，Arezou就赢了。否则火车最后会把电用光而停车，这样Borzou就赢了。换句话说，如果$c[0],c[1],\cdots ,c[k-1]$中至少有一个充电车站，且使得火车能够不断地充电而沿着环路跑个没完，Arezou赢。否则，它就会最终把电用光（有可能是在沿着环路跑好几圈后），Borzou赢。

现在给你一个这样的铁路系统。Arezou和Borzou将会玩$n$轮游戏。其中在第$s$轮游戏中（$0\leqslant s \leqslant n-1$），火车最初停在车站$s$上。你的任务是，对每一轮游戏，判断是否无论Borzou怎么玩，Arezou都必胜。


## 实现细节

你需要实现下面的函数

(C++) `std::vector who\_wins(std::vector<int> a, std::vector<int> r, std::vector<int> u, std::vector<int> v)`

(Java) `int[] who\_wins(int[] a, int[] r, int[] u, int[] v)`

- $a$：长度为$n$的数组。如果Arezou拥有车站$i$，则$a[i]=1$；否则Borzou拥有车站$i$，且$a[i]=0$。

- $r$：长度为$n$的数组。如果车站$i$是充电车站，则$r[i]=1$。否则$r[i]=0$。

- $u$和$v$：长度为$m$的数组。对于所有$0\leqslant i \leqslant m-1$，存在某一单向轨道，其起点为$u[i]$，终点为$v[i]$。

- 该函数需要返回一个长度为$n$的数组$w$。对于每个$0\leqslant i \leqslant n-1$，如果在火车最初停在车站$i$的游戏中，不管Borzou怎么玩，Arezou都能赢，则$w[i]$的值应为$1$。否则$w[i]$的值应为$0$。


## 输入格式

你需要实现上述子程序。


## 输出格式

你的子程序需要返回一个合法的结果。


## 样例 #1

### 样例输入 #1
```
a = [0, 1]
r = [1, 0]
u = [0, 0, 1, 1]
v = [0, 1, 0, 1]```

### 样例输出 #1

```
who_wins = [1, 1]```

## 提示

 ![](https://cdn.luogu.com.cn/upload/pic/6727.png) 

- 这里有$2$个车站。Borzou拥有充电车站$1$。Arezou拥有充电车站$1$，但是它不是充电车站。

- 这里有$4$段轨道$(0,0),(0,1),(1,0)$和$(1,1)$，其中$(i,j)$表示一个以车站$i$为起点、车站$j$为终点的单向轨道。

- 考虑火车最初停在车站$0$的游戏。如果Borzou将车站$0$的开关扳向轨道$(0,0)$，那么火车就会沿着这个环形轨道绕个没完（注意，车站$0$是一个充电车站）。在这种情况下，Arezou赢。否则，如果Borzou把车站$0$的开关扳向轨道$(0,1)$，Arezou可以把车站$1$的开关扳向轨道$(1,0)$。这样的话，火车将会在两个车站之间绕个不停。Arezou还是会赢，因为车站$0$是充电车站，火车将跑个没完。因此，无论Borzou怎么玩，Arezou都会赢。

- 根据类似的逻辑，在火车最初停在车站$1$的游戏中，无论Borzou怎么玩，Arezou也都会赢。因此，函数应当返回$[1,1]$。


## 数据范围和限制

- $1\leqslant n \leqslant 5000$

- $n \leqslant m \leqslant 20000$

- 至少会有一个充电车站。

- 每个车站至少会有一段轨道以它为起点。

- 可能会有某个轨道的起点和终点是相同的（即$u[i]=v[i]$）。

- 所有轨道两两不同。也就是说，不存在这样的两个下标$i$和$j$（$0\leqslant i < j \leqslant m-1$），使得$u[i]=u[j]$且$v[i]=v[j]$。

- 对于所有$0\leqslant i \leqslant m-1$，都有$0\leqslant u[i],v[i] \leqslant n-1$。


## 子任务

1. ($5$分)  对于所有$0 \leqslant i \leqslant m-1$，都有$v[i]=u[i]$或者$v[i]=u[i]+1$。

2. ($10$分)  $n\leqslant 15$。

3. ($11$分)  Arezou拥有所有车站。

4. ($11$分)  Borzou拥有所有车站。

5. ($12$分)  充电车站的数量为$i$。

6. ($51$分)  无任何限制。

