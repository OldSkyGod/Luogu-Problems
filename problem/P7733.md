# [JDWOI-2] 抢救实验数据

## 题目描述

实验中心可以看做一个 $n$ 个点 $m$ 条边的无向联通图。  
所有实验员每秒可以走到一个相邻的实验室并**收集**其中的数据，毒气每秒会蔓延到所有的相邻实验室。
当一个实验员**回到了大厅 $s$**，我们称他**抢救**了数据。  
实验员不能进入有毒气的实验室（如果他和毒气在同一秒进入实验室也不行）。  
**大厅周围有严格的保护措施，不会被毒气蔓延。（具体可以参考样例二）**  
现在所有实验员都在大厅 $s$，毒气泄露的实验室为点 $t$。假如有**足够多**的实验员同时出发，请问最多能抢救多少个实验室的数据？

## 输入格式

第一行两个正整数 $n,m$，表示实验中心的点数和边数。  
第二至 $m+1$ 行每行两个正整数 $u,v$，代表 $u,v$ 实验室之间有一条边。  
第 $m+2$ 行两个正整数 $s,t$，表示大厅和毒气泄露点。

## 输出格式

一行一个整数，表示最多能抢救多少个的实验室的数据。

## 样例 #1

### 样例输入 #1
```
4 3
1 2
2 3
3 4
1 4
```

### 样例输出 #1

```
1
```

## 样例 #2

### 样例输入 #2
```
6 7
1 2
2 3
3 1
4 5
5 6
6 4
1 4
1 4
```

### 样例输出 #2

```
2
```

## 样例 #3

### 样例输入 #3
```
15 14
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10
3 11
11 12
12 13
13 14
14 15
1 10
```

### 样例输出 #3

```
6
```

## 提示

**请注意常数因子带来的程序效率上的影响。**

【样例解释一】  
只有 2 号实验室可以到达并回来。

【样例解释二】  
因为大厅是坚不可摧的，所以 5,6 两个实验室会被毒气蔓延到，而 2,3 两个实验室永远不会被蔓延到。

【样例解释三】  
可以被抢救的点为：2,3,4,5,11,12。

【数据范围】  
**本题采用捆绑测试**。  
对于 $10\%$ 的数据，$2 \leq n,m \leq 20$；  
对于 $30\%$ 的数据，$2 \leq n \leq 2000,1 \leq m \leq 10000$；  
对于 $70\%$ 的数据，$2 \leq n \leq 2 \times 10^5$；  
对于 $100\%$ 的数据，$2 \leq n,m \leq 5 \times 10^6$。

由于读入量很大，这里提供 std 使用的快读模板（提交时需要选择 C++11 及以上)
```cpp
char gc() {
  static char now[1 << 20], *S, *T;
  if (T == S) {
    T = (S = now) + std::fread(now, 1, 1 << 20, stdin);
    if (T == S) return EOF;
  }
  return *S++;
}
template <typename T>
void Read(T &x) {
  x = 0;
  char c = gc();
  while (c < '0' || c > '9') c = gc();
  x = c - '0';
  while ((c = gc()) >= '0' && c <= '9') x = x * 10 + c - '0';
}
template <typename T, typename... Args>
void Read(T &x, Args &... args) {
  Read(x);
  Read(args...);
}
```
使用方法：`Read(n, m)` 或 `Read(x, y, z)` 等，可以读入任意个数，但是不能与 `std::cin` 和 `std::scanf` 一起使用。读入完成后 Windows 系统按 Ctrl+Z，Linux 系统按 Ctrl+D 结束。
