# 浏览器

## 题目描述

\_\_stdcall给了你n个点，第i个点有权值x[i]，对于两个点u和v，如果x[u] xor x[v]的结果在二进制表示下有奇数个1，那么在u和v之间连接一个Edge，现在\_\_stdcall想让你求出一共有多少个Edge。

如果你没能成功完成任务，那么\_\_stdcall会让你痛苦一下，你这个测试点就没分了。

## 输入格式

一行六个整数，n，a，b，c，d，x[0]。

n是点的个数，每个点的权值需要用如下的方式生成。

你需要使用a，b，c，d和x[0]生成一个数组x，生成方式是这样的。

$x_i = (ax_{i-1}^2 + bx_{i-1} + c) \mod d$

x[i]就是第i个点的权值，点的标号是1到n。

## 输出格式

输出一个整数，表示一共有多少个Edge。

## 样例 #1

### 样例输入 #1
```
8 98 24 20 100 44
```

### 样例输出 #1

```
12
```

## 样例 #2

### 样例输入 #2
```
1000 952537 601907 686180 1000000 673601
```

### 样例输出 #2

```
249711
```

## 提示

我们用v表示权值中的最大值。

对于前20%的数据，n<=10。

对于前40%的数据，n<=100。

对于前60%的数据，n<=1000。

对于前80%的数据，n<=1e6。

对于前90%的数据，v<=1e6。

对于100%的数据，n<=1e7，v<=1e9。

保证a，b，c，d，x[0]都是int内的非负整数。
